= Stateless authorization and delegation with Macaroons
Julien Tanguy
v1.1, 2017-10-15: Devfest 2017
:homepage: https://github.com/jtanguy/macaroons-hands-on
:twitter: jutanguy
:github: jtanguy
:blog: https://jtanguy.cleverapps.io
:backend: revealjs
:copyright: CC BY 4.0
:hashtag: #macaroons
:stem: latexmath
:source-highlighter: highlightjs
:revealjsdir: reveal.js
:revealjs_display: flex
:revealjs_theme: valwin
:title-slide-background-image: images/macaroons.jpg

[.two-columns]
== `whoami`

image::images/jutanguy.jpg[]

[.align-left]
--
- Web developer
- Functional enthusiast

//

- https://twitter.com/{twitter}
- https://github.com/{github}
- https://jtanguy.cleverapps.io
--

== Authentication

[quote, https://crypto.stackexchange.com/tags/authentication/info]
____
Authentication is successfully validating that an entity you are communicating
with is actually who they claim to be.
____

[NOTE.speaker]
====
This talk is about authorization and not authentication.
====

== Authorization

[quote]
____
Authorization is according or denying permission to a -- usually authenticated -- user.
____


[NOTE.speaker]
====
This talk is about authorization and not authentication.
====


=== Authorization schemes

- ACL linked directly to the user
- Anonymous bearer tokens

=== Bearer tokens

[quote]
____
A bearer token is a representation of a set of permissions.
____

=== Example permissions

- Viewing a specific file
- View and edit a specific file
- Anything a certain user can do

== Macaroons

- Google research paper published in 2014 <<pub41892>>

- Bearer token with a _signature_
- Decentralized _attenuation_ and _contextual confinment_ with _caveats_

== Anatomy of a macaroon

[frame=none, grid=none]
|===

|*Secret* | Nonce | Secret Key

|*Identifier* | Text/UUID | link to the secret

|*Location* | URL | Url of the emitter

|*Caveats* | [Caveat] | List of restrictions

|*Signature* 2+| Cryptographic hash of the macaroon
|===

== Caveats

____
*Ordered* list of _predicates_ which restrict the macaroon's authority
____

Two types of caveats:

- _first party_ caveats, which directly restrict the macaroon's authority, and
- _third party_ caveats, which require additional evidence.

=== First party caveats

Simple assertions

====
- `account = 123456`
- `file in ["accounts.pdf","bills.pdf"]`
- `time < 2017-05-18T14:45+02:00`
====

=== Adding first party caveats

. Macaroon stem:[m] (secret, identifier, location)
. assertion stem:[\mathcal{A}] = `account = 123456`
. stem:[m].addFirstPartyCaveat(stem:[\mathcal{A}])
. Done.


=== Signature

When adding a caveat, the signature is recomputed by hashing the current signature and the caveat string.

[.step]
- stem:[sig_0 = HMAC(secret,identifier)];
- stem:[sig_1 = HMAC(sig_0, caveat_0)];
- stem:[sig_2 = HMAC(sig_1, caveat_1)];
- etc…


=== Third party caveats

External predicates not listed in the macaroon

====
- The user must be logged to `auth.com` as _Alice_
- The user must have a valid session on our service as _Bob_
====

=== Adding third party caveat

[start=-3]
. Assertion stem:[\mathcal{A}] = 'user = Alice'
. Shared secret stem:[\mathcal{S}]
. Send stem:[\mathcal{A} + \mathcal{S}] to link:#[auth.com]
. Get back identifier stem:[\mathcal{id_{auth}}]
. Macaroon stem:[m] (secret, identifier, location)
. stem:[m].addThirdPartyCaveat(stem:[\mathcal{S}] ,stem:[\mathcal{id_{auth}}], link:#[auth.com])
. Done.

NOTE: _The shared secret is **not** in the resulting token_

== Verifying macaroons

[.step]
- Signature
- First party caveats
- Third party caveats

=== Verifying the signature

[.step]
. stem:[sig_0 = HMAC(secret,identifier)];
. stem:[sig_1 = HMAC(sig_0, caveat_0)];
. stem:[sig_2 = HMAC(sig_1, caveat_1)];
. etc…


=== Verifying first party caveats

[.step]
. Parse the predicate
. Verify it
. ???
. Profit !

=== Verifying third party caveats

Third party macaroons must be _discharged_ by another macaroon, which must verify

[.step]
- The root secret of the discharging macaroon must match the one used to mint the caveat
- The verifier id must match
- The discharging caveat must be bound to the discharged caveat

== Macaroons vs JWT

=== Similarities

[.step]
- Token
- Signature

=== Differences

[frame=none, grid=none, options=header]
|===
| | Macaroon | JWT

| Hashing algorithm | HMAC-SHA256  | In the payload

| Additional data | Caveats (restrictive) | Claims (additive)

| Delegation | Possible (client-side) | Impossible (new JWT required)
|===


== Usecases

== File sharing website

=== Dropbox/Google Drive clone

- Access to files with macaroons
- Shareable and re-shareable links

=== Example

[.step]
. Macaroon stem:[m_{julien}]
. Julien shares to Alice with a caveat
+
`prefix = subfolder` -> stem:[m_{alice}]
. Alice shares to Bob with a caveat
+
`mode = readonly` -> stem:[m_{bob}]

== Authorization for microservices

Clever Cloud usecase

- Immutable deployments
- Microservice architecture
- No trusted network model

=== Managing build caches

- Build caches backed up on a S3-like
- Application deployer
- Build cache uploader

[.fragment]
.Problem
____
Distributing keys and secrets to the build caches
____

=== New microservice: An S3 api gateway

[.step]
- Stores all the keys and secrets, encrypted in a database
- A _root_ macaroon is given to the application deployer
- The application deployer passes it to the build cache uploader
- The build cache uploader can request pre-signed urls to the s3 gateway directly


== Links

[bibliography]
- [[[pub41892]]] Arnar Birgisson et al. _Macaroons: Cookies with
Contextual Caveats for Decentralized Authorization in the Cloud_. Network and
Distributed System Security Symposium, Internet Society. 2014.
https://research.google.com/pubs/pub41892.html
- [[[cordellBlog]]] Evan Cordell. _Macaroons 101: Contextual Confinement_.
Elegent authorization, for a more civilized age. 2015.
http://evancordell.com/2015/09/27/macaroons-101-contextual-confinement.html
- [[[libmacaroons]]] _First implementation_. https://github.com/rescrv/libmacaroons

