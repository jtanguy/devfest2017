= Macarons: des cookies en mieux !
Julien Tanguy
v2.0-fr, 2017-10-20: Devfest 2017
:homepage: https://github.com/jtanguy/devfest-macaroons
:twitter: jutanguy
:github: jtanguy
:blog: https://jtanguy.cleverapps.io
:backend: revealjs
:copyright: CC BY 4.0
:hashtag: #macaroons
:stem: latexmath
:source-highlighter: highlightjs
:revealjsdir: reveal.js
:revealjs_display: flex
:revealjs_theme: valwin
:title-slide-background-image: images/macaroons.jpg

[.two-columns]
== `whoami`

image::images/jutanguy.jpg[]

[.align-left]
--
- Développeur chez link:https://www.valwin.fr[Valwin]
- On recrute !

//

- https://twitter.com/{twitter}
- https://github.com/{github}
- {blog}
--

[NOTE.speaker]
====
Bonjour, je suis

- Julien
- Développeur chez Valwin
- en recherche d'un dev front

et je suis venu vous parler d'autorisation distribuée
====

== Autorisation

== Authentification vs Autorisation

____
Qui suis-je ?
____

[.fragment]
____
Qu'ai-je le droit de faire ?
____


[NOTE.speaker]
====
Quand on parle d'auth sur le net, on met souvent ensemble deux concepts:
- L'authentification, qui est le processus qui détermine qui suis-je
-- 2FA (ou MFA)
-- mot de passe
-- authenticator (TOTP)

- L'autorisation, qui est le processus qui détermine ce que j'ai le droit de faire.
====

=== _Bearer tokens_

[quote, RFC6750]
____
A security token with the property that any party in possession of the token (a "bearer") can use the token in any way that any other party in possession of it can.
____

[NOTE.speaker]
====
En autorisation, on parle généralement de _bearer token_.
C'est un token qui représente un ensemble de permissions, et toute personne qui possède ce token a le droit de faire les mêmes choses.
====

=== Exemple: Google drive

https://drive.google.com/open?id=197u0vRt8_VvTa0GaNknMRVQkm-Q

[NOTE.speaker]
====
Dans ce lien de partage de drive, on peut voir la partie `id`, qui représente quelque part ce qu'on appelle un _bearer token_, ou un badge d'accès à toute personne qui le possède.
====


== Cas d'usage: Partage de fichiers

[.step]
- Système de fichiers dans le cloud
- Je veux partager un dossier à _Alice_
- _Alice_ veut repartager une partie de ce dossier à _Bob_

[NOTE.speaker]
====
Prenons un petit exemple de service dans lequel nous aimerions faire de l'autorisation.

On a un service de partage de fichiers, dans lequel je stocke toutes mes données.

Je souhaite partager un de mes dossiers à Alice, car on travaille ensemble sur un projet et elle me relit.

Je lui envoie un lien qui lui permet d'accéder au dossier en question et elle peut accéder aux fichiers.

Seulement Alice souhaite faire relire certains fichiers à Bob, mais certains fichiers dans le dossier sont sensibles.

Elle ne veut pas lui donner accès à tout le dossier, et est obligé de me redemander un lien pour le passer à Bob.

Le problème (et l'avantage) avec les _bearer token_ classiques, c'est qu'un token, une fois émis, ne peut pas *évoluer* sans changement côté serveur.
Je peux stocker une ACL dans une DB pour mes tokens, et faire évoluer cette ACL, mais Alice ne peut rien faire si elle n'a pas un compte sur le service.
====

== _Macaroons_

- Papier de recherche Google publié en 2014 <<pub41892>>

- Restriction des accès avec des _caveats_

[NOTE.speaker]
====
C'est dans cette optique que des chercheurs chez Google ont conçu le concept de _Macaroons: Des cookies avec des caveats pour de l'autorisation décentralisée dans le Cloud_

Conceptuellement, ce sont des tokens que l'on peut affaiblir en y rajoutant des contraintes que l'on appelle des _caveats_.

Alors concrètement un macaron c'est quoi ?
====

== Anatomie d'un _macaroon_

[.step]
- Secret
- Identifiant
- Url
- Signature
- _Caveats_

[NOTE.speaker]
====
À la base, c'est un ensemble de 5 éléments:
- un secret (une clé privée)
- un identifiant (un lien vers le secret)
- une url (pour identifier l'émetteur)
- une signature (pour empêcher les contrefaçons)
- un ou plusieurs _caveats_
====

=== Création

. Macaroon stem:[m] = `Macaroon.create(secret, identifier, location)`
. Done.

[NOTE.speaker]
====
Pour créer un macaron, on prend notre secret, notre identifiant, et notre url, et on on appelle notre fonction create

À la base, un macaron est appelé un macaron racine. Il a la plus grande autorité.

On peut ensuite restreindre cette autorité en y rajoutant des caveats.
====

== _Caveats_

____
Liste *ordonnée* de prédicats qui limitent l'autorité d'un _macaroon_
____

[.fragment]
====
Deux types de _caveat_
- primaires (_first party_)
- tiers (_third party_)
====

[NOTE.speaker]
====
C'est un ensemble de prédicats, ou de contraintes qui limitent l'autorité d'un macaron.


Il existe deux types de caveats:
- des caveats primaires, ou first-party caveats, et
- des caveats tiers, ou third party caveats
====

== _Caveats_ primaires

====
- `account = 123456`
- `file in ["accounts.pdf","bills.pdf"]`
- `time < 2017-05-18T14:45+02:00`
====

[NOTE.speaker]
====
Les caveats primaires sont des prédicats émis et vérifiés pour l'émetteur du macaron.

On peut tout mettre dedans, mais en général on utilise une forme standard du style

clé >/=/< valeur
====

=== Ajout

[start=0, role=fullwidth]
. Macaroon stem:[m],  assertion stem:[\mathcal{A}] = `account = 123456`
. stem:[m].addFirstPartyCaveat(stem:[\mathcal{A}])
. Done.

[NOTE.speaker]
====
Pour ajouter un caveat à un macaron, c'est très simple. 

Il suffit de prendre n'importe quel macaron (que l'on a pas nécessairement créé), et d'y rajouter le caveat
====

=== Vérification

====
- `account = 123456`
- `file in ["accounts.pdf","bills.pdf"]`
- `time < 2017-05-18T14:45+02:00`
====


[NOTE.speaker]
====
Le caveat est vérifié par l'émetteur du macaron, qui est indiqué dans le macaron (le champ _location_)
====


== _Caveats_ tiers

Prédicats externes non listés dans le _macaroon_.

====
- L'utilisateur doit être authentifié chez `auth.com` comme _Alice_
- L'utilisateur doit être authentifié comme _Bob_
====

[NOTE.speaker]
====
Les caveats tiers sont un moyen de créer des assertions entre différents services, ou différents émetteurs.

Contrairement aux caveats primaires qui peuvent être rajoutés par n'importe qui sur n'importe quel macaron, les caveats tiers sont plutôt destinés aux restrictions de service à service
====

=== Ajout

[start=-3, role=fullwidth]
. Assertion stem:[\mathcal{A}] = 'user = Alice', secret stem:[\mathcal{S}]
. Envoi de stem:[\mathcal{A} + \mathcal{S}] à link:#[auth.com]
. On récupère l'identifiant stem:[\mathcal{id_{auth}}]

[start=0, role=fullwidth]
. Macaroon stem:[m]
. stem:[m].addThirdPartyCaveat(stem:[\mathcal{S}] ,stem:[\mathcal{id_{auth}}], link:#[auth.com])
. Done.

[.fragment]
NOTE: _Le secret partagé n'est *pas* dans le macaron final_

[NOTE.speaker]
====
L'ajout d'un caveat tiers se passe en deux temps.

Tout d'abord: on discute avec le tiers pour lui envoyer l'assertion et une clé secrète, et on récupère un identifiant. 

Ensuite on ajoute le caveat, en lui passant les informations nécessaires.

On note que le prédicat n'est pas passé au macaron. Si on inspecte le macaron, on ne peut pas savoir quelle est l'assertion utilisée par le caveat, si ce n'est son origine.
====

=== Vérification

Un _caveat_ tiers doit être _déchargé_ par un autre macaron.

[NOTE.speaker]
====
Pour vérifier le caveat tiers, il faut une information du tiers en question.

Cette information est sous la forme d'un autre macaron, appelé macaron de décharge.
C'est un macaron qui a été créé avec le secret partagé, et l'identifiant partagé.

Il doit être également lié au macaron que l'on veut vérifier pour éviter la réutilisation.

Il y a en plus une information supplémentaire dans le caveat (stem:[vid = Enc(sig, caveat\_key)])

Comme c'est un macaron, il peut y avoir d'autres caveats primers ou tiers
====

== Signature

La signature est recalculée à chaque fois que l'on rajoute un _caveat_.

[.step]
- stem:[sig_0 = HMAC(secret,identifier)];
- stem:[sig_1 = HMAC(sig_0, caveat_0)];
- stem:[sig_2 = HMAC(sig_1, caveat_1)];
- etc…

[NOTE.speaker]
====
Je vous avais parlé tout à l'heure d'une signature. 

C'est le mécanisme principal qui empêche d'enlever des caveats.

HMAC: fonction de hash crypto qui ne peut (théoriquement) pas être inversée
====

== _Macaroons_ vs JWT

[NOTE.speaker]
====
J'aimerais faire une petite comparaison avec les Json Web Tokens
====

=== Similitudes

[.step]
- Token
- Signature

=== Différences

[frame=none, grid=none, options=header]
|===
| | _Macaroon_ | JWT

| Algo de hash | HMAC-SHA256  | Dans le JWT

| Donnée additionnelle | Caveats (soustractif) | Claims (additif)

| Délégation | Possible (client-side) | Impossible (nouveau JWT)
|===

[NOTE.speaker]
====
Là où les claims sont additifs (on peut rajouter `admin: true`) à un JWT pour en augmenter le pouvoir,
les caveats sont restrictifs (tout le monde peut en rajouter je vous le rappelle)
====

== Exemple: Partage de fichiers

- Accès aux fichiers grâce à des macarons
- On peut modifier et restreindre le partage

[NOTE.speaker]
====
Si on reprend notre exemple de tout à l'heure et qu'on y met des macarons
====

=== Exemple

[.step]
. _Macaroon_ stem:[m_{julien}]
. `prefix = subfolder` -> stem:[m_{alice}]
. `mode = readonly` -> stem:[m_{bob}]

[NOTE.speaker]
====
====

== Autorisation dans un contexte microservices

image::images/cclogo.png[Clever Cloud, auto, 200, role=plain, background=white]

- Infrastructure immutable
- Microservices

[NOTE.speaker]
====
====

=== Gestion des caches de build

- Caches sauvegardés sur un S3-like
- Service qui gère le déploiement de l'application
- Service qui gère le cache de build

[NOTE.speaker]
====
====

== Implémentations

http://macaroons.io

.Langages supportés
====
C, C#, Go, Java, Javascript, Python, Ruby, Rust, PHP (Haskell)
====

[NOTE.speaker]
====
Vous pouvez tester des macarons sur le site macaroons.io, et il existe plusieurs bibliothèques dans différents languages.

(Je mets haskell entre parenthèses car mon implem n'est pas encore totalement finie)
====

== Liens

[bibliography]
- [[[libmacaroons]]] _Implémentation de référence_. https://github.com/rescrv/libmacaroons
- [[[pub41892]]] Arnar Birgisson et al. _Macaroons: Cookies with
Contextual Caveats for Decentralized Authorization in the Cloud_. Network and
Distributed System Security Symposium, Internet Society. 2014.
https://research.google.com/pubs/pub41892.html
- [[[cordellBlog]]] Evan Cordell. _Macaroons 101: Contextual Confinement_.
Elegent authorization, for a more civilized age. 2015.
http://evancordell.com/2015/09/27/macaroons-101-contextual-confinement.html

== Merci

- https://twitter.com/{twitter}
- https://github.com/{github}
- {blog}
